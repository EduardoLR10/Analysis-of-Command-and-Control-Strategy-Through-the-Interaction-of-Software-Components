\section{Channel System}
\label{sec:channelSystem}

To justify and motivate the use of a CS, we need to establish our requirements. Recalling our motivation example (Section \ref{sec:motivation}), the team's members execute tasks in parallel and each member exchange information with the leader, changing its decisions based on the instructions its receives, i.e, which tasks are allocated for it. Moreover, dynamic events also changes its attitudes, e.g, sensor failure causes an information exchange with the leader, to update the task allocation process. Thus, the capability of coping with context changes eventually arising during a mission in a \textit{nondeterministic} way motivate the use of \textit{program graphs}~\cite{modelcheckingBaier}. Furthermore, the execution of parallel processes and the communication among members are requirements that prompt the use of \textit{channel systems}~\cite{modelcheckingBaier}.

A channel system is composed of a group of data-dependent processes communicating with each other via \textit{communication actions}~\cite{modelcheckingBaier}. With a program graph representing each process, transitions among states can be classified between conditional transitions or communication actions. Conditional transitions are important to avoid transitioning to states undesirably, according to boolean evaluations~\cite{modelcheckingBaier} defined during planning. The last type of transition works transmitting values through channels or receiving values from channels and assigning them to variables~\cite{modelcheckingBaier}. Additionally, channels can have a finite or infinite capacity of messages in a single channel, as well as a specified type of messages that can be stored in it. Finally, channel systems provide a notion of synchronization, whereas channels with a capacity different from zero function in a \textit{asynchronous} way and null capacity channels represent \textit{synchronous} communication~\cite{modelcheckingBaier}.

\begin{figure}[!ht]
    \centering
    \scalebox{.75}{\input{tikz/channelSystem}}
    \caption{Proposed Channel System}
    \label{fig:CS}
\end{figure}

Figure \ref{fig:CS} illustrates our channel system. The proposed channel system describes our coordination strategy. We decided to model our coordination using separate roles, mainly due to its nature of modulatizing functional aspects~\cite{roleOrientedModeling}. Also, roles are used to define positions within an organization, encapsulating certain tasks, responsibilities, and goals that an owner of a role has to fulfil~\cite{roleOrientedModeling}. Thus, each member of the team can posses a program graph that describes a distinct role, and more than one role can coexist in the same entity. Also, during maneuvering between different C2 approaches~\cite{france2014}, roles assignment can be changed, providing more possibilities to the team during the mission.

To modularize roles, we divided the coordination aspect among two different roles:

\begin{itemize}
    \item Task Allocator (TA): responsible for distributing tasks throughout the team, based on team members attributes, such as fuel and sensors onboard. Moreover, this role reports results provided by executors to the C2 approach selector role;
    \item C2 Approach Selector (C2S): responsible for detecting the need of changing the C2 approach, due to some drop in performance reported by task allocator. Additionally, it communicates to task allocator if a maneuver will occur.  
\end{itemize}

Furthermore, each member executes its set of roles encapsulated in it. For instance, as depicted in Figure \ref{fig:CS}, each member playing the executor (EX) role communicates with the leader, i.e, member who plays the role TA, using channel \textit{$ch_1$} in a asynchronous manner. Similarly, the leader provides tasks to each executor member using channel \textit{$m_i$} whereas $i$ is the executor's index. Finally, the C2S role and TA role exchange information using synchronized channels \textit{$ch_2$} and \textit{$ch_3$} to asses performance and check if a maneuver is crucial to maintain quality of execution during the mission. These latter channels use synchronized communication because the TA role provides performance information using channel \textit{$ch_3$} and waits for the C2S's response to know if a maneuver might happen. Until this feedback information approaches the channel \textit{$ch_2$}, the TA role stops allocating tasks to the remaining members. However, members that execute tasks, i.e, play the EX role, and allocate tasks, i.e, play the TA role, don't need to wait for any response and can continue executing tasks or allocating tasks, justifying the asynchronous communication between these roles.

\begin{figure}[!ht]
    \centering
    \scalebox{.65}{\input{tikz/taskAllocator}}
    \caption{Task Allocator Role Program Graph}
    \label{fig:TA}
\end{figure}

Figure \ref{fig:TA} illustrates the TA role's program graph. First, it receives a set of available tasks ($T'$) and team members set ($E'$), from the C2S role over synchronous channel ($ch_2$), transitioning from location \textit{Waiting} to \textit{Ready}. Next, taking to account the current C2 approach ($\omega$), TA performs task allocation (action $allocate$ followed by function $f\_alloc$) and notifies each member $k$ (moving from location \textit{Notifying} to location \textit{Binding}) of its assigned tasks via an specific asynchronous channel $m_k$. After communicating with each executor member, TA returns to the \textit{Ready} location. Eventually, TA will be notified, over a shared asynchronous channel $ch_1$, about members status, such as completed and failed tasks. In the case of a negative feedback, TA will perform a new task allocation with the remaining tasks. If, in the allocation process, it detects that the current C2 approach is not performing as expected, it communicates to C2S role, using the synchronous channel $ch_3$ (advancing from \textit{Allocating} to \textit{Waiting}).

\begin{figure}[!ht]
    \centering
    \scalebox{.65}{\input{tikz/c2ApproachSelector}}
    \caption{C2 Approach Selector Role Program Graph}
    \label{fig:C2S}
\end{figure}

Finally, at the coarsest-grained level of coordination, C2A specifies a C2 approach change protocol (cf. Figure~\ref{fig:c2a_pg}). C2A starts operation by receiving mission tasks, member information, and initial C2 approach from the C2CS call ($g_0$ at location \textit{Notifying}). From this initial location, it goes to the location \textit{Operating} with the initial C2 approach $w_0$ and sends the set of tasks $T$ and the team $E$ through the synchronous channel $ch_2$. The C2A keeps in $Operating$ location up to eventually receive, from TA, the pair formed by the set of not allocated tasks and the team's members updated.Such information comes through the synchronous channel $ch_3$ and takes C2A to the location \textit{Maneuvering}.

The tasks received and the last information about the team are analysed with the action $update$. In case of the function \emph{find\_maneuver} be $NULL$, i.e., there is no C2 Approach to be operated in order to perform the tasks with the available team, we register those tasks as failed ($T_{fail}$) and we notify TA with an empty set of tasks. In such case, the C2A goes to the location \emph{Operating} passing through \emph{Notifying} and adopts a C2 Approach $w_f$ to be operated. This C2 Approach can be any one of the C2 Approach Space and it can guarantee more than one passing through the C2 Approaches. Otherwise, the  \emph{find\_maneuver} function returns a suitable C2 Approach to be operated following the diagonal in C2 Approach Space according to the maturity levels.
With C2 Approach defined, C2A sends mission's tasks and members' information to the TA over the synchronous channel $ch_2$, then moving to the location \emph{Operating}.

