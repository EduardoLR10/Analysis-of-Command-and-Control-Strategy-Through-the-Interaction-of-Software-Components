\section{Channel System}
\label{sec:channelSystem}

To justify our choice of a typed-parameterized extension of a channel system, we need to establish our requirements. Recalling our motivation example (Section \ref{sec:motivation}), the team's members execute tasks in parallel and each member exchange information with the leader, changing its decisions based on the instructions its receives, i.e, which tasks are allocated for it. Moreover, dynamic events also changes its attitudes, e.g, sensor failure causes an information exchange with the leader, to update task's allocation process. Thus, the capability of coping context changes eventually arising during a mission in a \textit{nondeterministic} way motivate the use of \textit{program graphs}~\cite{modelcheckingBaier}. Furthermore, the execution of parallel processes and the communication among members are requirements that prompt the use of \textit{channel systems}~\cite{modelcheckingBaier}.

A channel system is composed of a group of data-dependent processes communicating with each via \textit{communication actions}~\cite{modelcheckingBaier}. With a program graph representing each process, transitions among states can be classified between conditional transitions or communication actions. Conditional transitions are important to avoid transitioning to states undesirably, according to boolean evaluation~\cite{modelcheckingBaier} defined during planning. The last type of transition works transmitting values through channels or receiving values from channels and assigning them to variables~\cite{modelcheckingBaier}. Additionally, channels can have a finite or infinite capacity of messages in a single channel, as well as a specified type of messages that can be stored in it. Finally, channel systems provide a notion of synchronization, whereas channels with a capacity different from zero function in a \textit{asynchronous} way and null capacity channels represent \textit{synchronous} communication~\cite{modelcheckingBaier}.

\begin{figure}[!ht]
    \centering
    \scalebox{.75}{\input{tikz/channelSystem}}
    \caption{Channel System Representation}
    \label{fig:CS}
\end{figure}

Figure \ref{fig:CS} illustrates our channel system. The proposed channel system describe our coordination strategy. We decided to model our coordination using separate roles, mainly due to its nature of isolating functional aspects~\cite{roleOrientedModeling}. Also, roles are used to define positions within an organization, encapsulating certain tasks, responsibilities, and goals that an owner of a role has to fulfil~\cite{roleOrientedModeling}. Thus, each member of the team can posses program graphs that describe each role, and more than one role can coexist in the same entity. Also, during maneuvering between different C2 approaches~\cite{france2014}, roles can be added or removed, providing more possibilities to the team during the mission.

To separate roles, each one with a proper and unique set of functions, we divided the coordination aspect among two different roles:

\begin{itemize}
    \item Executor: responsible for executing tasks and providing feedback about which tasks it did to the member with the task allocator role.
    \item Task Allocator: responsible for distributing tasks throughout the team, allocating tasks within the knowledge of member's attributes, such as fuel, sensors, etc.
    \item C2 Approach Selector: responsible for detecting potential sufficient approaches, due to some drop in performance reported by task allocator.
\end{itemize}

Furthermore, each member execute its role or set of roles encapsulated in it. For instance, as depicted in Figure \ref{fig:CS}, each member who detains an executor role communicates with the leader, i.e, member who holds the role task allocator, using channel \textit{$ch_1$} in a asynchronous manner. In a similar way, the leader provides tasks to each executor member using channel \textit{$m_2$}. Finally, the C2 approach selector role and task allocator role exchange information using synchronized channels \textit{$ch_2$} and \textit{$ch_3$} to asses performance and check if a maneuver is crucial to maintain quality of execution during the mission. These last channels use synchronized communication because the task allocator role provides performance information using channel \textit{$ch_3$} and waits for the C2 approach selector's response to know if a maneuver might happen. Until this feedback information approaches the channel \textit{$ch_2$}, the task allocator role stops allocating tasks to the remaining members. However, members that execute tasks, i.e, possess executor roles, and allocate tasks, i.e, holds task allocator role, don't need to wait for any response and can continue executing tasks or allocating tasks, justifying the asynchronous communication between these roles.